// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransactions(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-deleted":       true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-deleted" -------------
	if paramValue := ctx.QueryParam("include-deleted"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-deleted", ctx.QueryParams(), &params.IncludeDeleted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-deleted: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":          true,
		"round":           true,
		"include-deleted": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-deleted" -------------
	if paramValue := ctx.QueryParam("include-deleted"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-deleted", ctx.QueryParams(), &params.IncludeDeleted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-deleted: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":          true,
		"application-id":  true,
		"include-deleted": true,
		"limit":           true,
		"next":            true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-deleted" -------------
	if paramValue := ctx.QueryParam("include-deleted"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-deleted", ctx.QueryParams(), &params.IncludeDeleted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-deleted: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":          true,
		"include-deleted": true,
		"limit":           true,
		"next":            true,
		"creator":         true,
		"name":            true,
		"unit":            true,
		"asset-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-deleted" -------------
	if paramValue := ctx.QueryParam("include-deleted"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-deleted", ctx.QueryParams(), &params.IncludeDeleted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-deleted: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-deleted":       true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-deleted" -------------
	if paramValue := ctx.QueryParam("include-deleted"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-deleted", ctx.QueryParams(), &params.IncludeDeleted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-deleted: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransactions(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"ZQmkH35xI0e/OBK6+eXm/wcAAP//YyymKp7xAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
