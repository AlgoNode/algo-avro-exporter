// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransactions(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-deleted":       true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-deleted" -------------
	if paramValue := ctx.QueryParam("include-deleted"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-deleted", ctx.QueryParams(), &params.IncludeDeleted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-deleted: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":          true,
		"round":           true,
		"include-deleted": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-deleted" -------------
	if paramValue := ctx.QueryParam("include-deleted"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-deleted", ctx.QueryParams(), &params.IncludeDeleted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-deleted: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":          true,
		"application-id":  true,
		"include-deleted": true,
		"limit":           true,
		"next":            true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-deleted" -------------
	if paramValue := ctx.QueryParam("include-deleted"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-deleted", ctx.QueryParams(), &params.IncludeDeleted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-deleted: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":          true,
		"include-deleted": true,
		"limit":           true,
		"next":            true,
		"creator":         true,
		"name":            true,
		"unit":            true,
		"asset-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-deleted" -------------
	if paramValue := ctx.QueryParam("include-deleted"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-deleted", ctx.QueryParams(), &params.IncludeDeleted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-deleted: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":          true,
		"include-deleted": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-deleted" -------------
	if paramValue := ctx.QueryParam("include-deleted"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-deleted", ctx.QueryParams(), &params.IncludeDeleted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-deleted: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-deleted":       true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-deleted" -------------
	if paramValue := ctx.QueryParam("include-deleted"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-deleted", ctx.QueryParams(), &params.IncludeDeleted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-deleted: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransactions(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
