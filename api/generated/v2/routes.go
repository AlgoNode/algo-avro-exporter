// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"D7+4kaNfHAXd/HTz3wEAAP//W4HGIFkIAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
