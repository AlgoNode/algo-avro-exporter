// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9fW/cNtYo/lWI+T1Ak/2N7LRpF7cBFg/SZIMGm3SDOO0CN+7Fw5E4M6wlUiUp29Pc",
	"fPcLnkNSlETNaOyxk7TzV+IRXw7Jw8Pzfj7MclnVUjBh9OzJh1lNFa2YYQr+onkuG2EyXti/CqZzxWvD",
	"pZg98d+INoqL1Ww+4/bXmpr1bD4TtGJtG9t/PlPs94YrVsyeGNWw+Uzna1ZRO7DZ1La1G+njx/mMFoVi",
	"Wg9n/bcoN4SLvGwKRoyiQtPcftLkips1MWuuietMuCBSMCKXxKw7jcmSs7LQJx7o3xumNhHUbvJxEOez",
	"64yWK6moKLKlVBU1syezp67fx52f3QyZkiUbrvGZrBZcML8iFhYUDocYSQq2hEZraoiFzq7TNzSSaEZV",
	"viZLqXYsE4GI18pEU82evJ9pJgqm4ORyxi/hv0vF2B8sM1StmJn9Ok+d3dIwlRleJZb20p2cYropjSbQ",
	"Fta44pdMENvrhLxutCELRqggb188I48fP/6e4DYaVjiEG11VO3u8pnAKBTXMf55yqG9fPIP5z9wCp7ai",
	"dV3ynNp1J6/P0/Y7efl8bDHdQRIIyYVhK6Zw47Vm6bv61H7ZMo3vuGuCxqwzizbjB+tuvCa5FEu+ahQr",
	"LDY2muHd1DUTBRcrcsE2o0cYprm7G7hgS6nYRCzFxgdF03j+T4qneaMUE/kmWylG4eqsqRhuyVu3FXot",
	"m7Iga3oJ66YVvAGuL7F98ZwvadnYLeK5kk/LldSEuh0s2JI2pSF+YtKI0tIsO5rDQ8I1qZW85AUr5paM",
	"X615viY51TgEtCNXvCzt9jeaFWPbnF7dDjQPnSxcN9oPWNDnuxntunbsBLuGi5DlpdQsM3LHW+WfHyoK",
	"Er8u7cOl93u5yLs1IzC5/YCvNuydsAhdlhti4FwLQjWhxL9Tc8KXZCMbcgWHU/IL6O9WY3etInbT4HA6",
	"j6rlTMa2b7AZic1bSFkyKmDzHJeS0bLcQi/LknDDKu2YGksaYYIikNI5KVjJYJHtcwC/aqPkBhavmW0n",
	"a8OKTDbGIcValnZAPYcTwWHxc/T4lDKnpTbUsFGGKF7JjkWXvOJmuNzX9JpXTUVEUy2YsgfuaauRRDHT",
	"KAGHrRjJ4cwWwPVw252WpKYrpgmzpJcjNwfz2KshpCGK0Xw9jvcI0w5Ur+h1pmQjiglMiyFSxY+CrlnO",
	"l5wVJIwyBks7zS54uNgPnpaVisDxg4yCE2bZAY5g14ljtdfTfoEDik71hPzsqBN8NfKCiUDEyGIDn2rF",
	"LrlsdOg0AiNMvV1cENKwrFZsya+HQJ657bAUAts4Elq59zuXwlAuWGGpKwAtDUNqMwpTNOG+TMqCavb3",
	"b8de6ParYhdskyS6fQTA5QSpaG2/YN/tqwgz7LjUE/FwKfv4txX3JuEdNMqQbCReYfvVEZW0BNrpP0EG",
	"jedG+Se7lSyKY/jnbWwrejPdHdur+SrDEQe3hK/e2bd4yUt4p3+zl8OfbKPtu9Q9W/9ya74S1DSKPTkX",
	"f7N/kYycGSoKqgr7S4U/vW5Kw8/4yv5U4k+v5IrnZ3w1tike1qRsCt0q/MeOl5ZFzXVYbmoK/zk1Q01t",
	"wwu2UczOQfMl/HO9BESiS/XHDKW8sZlTgtgrKS+aOt7JvKOYWGzIy+djWAJDbiOEQDR0LYVmgK5PkYN4",
	"636zP1laxwSQ8ogJOP1NS2By27FrJWumDGexIsj+978UW86ezP6/01ZxdIrd9KmbsJUrzNgbhjeXGke7",
	"kGY5aoZcQFU3Bt/0FFkI9/h9gK0/Z3sscvEbyw1uUBeMB6yqzeahBdjBrg+3W/B/YO722DcHMlWKbu54",
	"H/FVz+B1Ho78s+VBLUmv6YoLWPicXK2ZIBW9sOSACmnWTBF7Fkwb/74j3cMnP2iwHJPgOO2TWerGJM5U",
	"3/pQ21N7JVcHOdsdep3z8/e0rnlxfX7+a4fP5qJg1+ljuNMzLuUqK6ih05Gxs2fPbdcEXn6+qNPXmR0K",
	"gQ6LPHucwv2S00Nt14Evm74J/h4JauJW3J6oas3MD7SkImeHOOWFG2ryCb/mggMQP6KC43jM/pjDVh7i",
	"iA9xge04Oy8sNLpfnhGmPMQm6UPt0h4Ezu/XEefDWd4a438oZX5xo7PcdlQw6o6Z/6mUVAfAIs/k9VY9",
	"n1VMa7piadVZvJO+4ZSt8wDDsTO7BFAw/MhoadbP1uwONjMae8eWvmtF6gNs7J1eq0j637X+aFU7uLbu",
	"sHvehGga/bnv3udDlDpbPp2Wd860T9Gnn7He75A/ei1SrCZKuA04Fx8uUJdoxVhqCHVWcNTunotz8Zwt",
	"uQBjzZNzYenQ6YJqnuvTRjPlOMWTlSRPiBvSSpXnYjbvP4RjqlYwdDpo6mZR8pxcsE3qFNACm5bLy5W0",
	"UrmRhpaRKSqyyzoDQKtSGqIcTpBZzJCNyZw/Q6bYFVVFAnQdzA8wMhqIt806J25stJI4fwk3fvoa0LrW",
	"GRjyMrDkjaklyp5SQqP1j9gjI9pI5W0gXHto4Hx/ksbZFegVQfwijWaa/E9F6/dcmF9Jdt48evSYkad1",
	"/cqOeWbh+B9nE7D3aVOjZXVvFYQfLMXxwMLhPDN2bRTNwFKYXL5htIbTXzOimwqMzmVJoFtHUVMruVK0",
	"ckbHsAC/H+MHgHBMe8uiFcLizrCX9+JJLwE+wRFCG7JmpbOm3eK8Ijnqxse1Qxbb4jd0fv4eXIL8yQQX",
	"ghXlQvtXQfOVsJfAeVssGMktF8CKE/JySYCqzTvdnc+fo5iBdHCNDhLknV0j2MZITgU4TtQFOBJwQajY",
	"9JXymhnjTSBv2QXbvItMa3uaaJwdnu54EovGDheexfaEyRXVpJJgnsmZMOXGmfYTqJkGpuHCoI0xR/eJ",
	"zOLvGNGAWxN5cNiLE5MQN0YfESOHBlrXZFXKhaM0AUWfBBz1fcaJyhsLgD4AQUkKTn4btty9mqrERuBF",
	"HNmCGyzUjnera7h1eTdGuSVXGtxGGHVvBI2vyA0wz/m0DEH5z5oBVyYV+HZ0UUr7K51C+mCyns9qqgzP",
	"eT1N1Yqjv+n0sYPsetqTj7lc9t/swZOafEKwcbagOv18M/vFYmCj0d/JrtETOj8TcsuwghMC9ml3VRcl",
	"uEAF90w8Y6rAN8svG90Vx0BL3wumRMtTeTC6OxIzb2uqvZsWeLN5EjGJzRlB3nd2AwCB7b2JsDfmW7md",
	"t2SXdGz/x03jL0VhaQfTXZe1YPj2z0r/+s+Dhwm6oXsDubeKe1O4/ddie1OWhC9JIy6EvLLM8T7G7vnM",
	"cn5N+pCkAM7P3rkVbgc29ujjAP5KR8dmofr3cllywUhGeNgDA3uAjocy5+h9195PNwezgsHfiMVBO8Dk",
	"EVLIHYFdS1niwOQnGd9YsdoHSME40BjqxwZiE/3NJqidgrOGEzl2igZDitJerXnrDoPHOJTngon6TZ+4",
	"JaW2TiuCTRZOCokesRTiWoKVW7Ff6AacT43MZXkyENc0KxnQ/6xDbzMrmiU5PQZoeOa7RaIcecCXlvF6",
	"GBF4xVZcG6acGA8QBo+i1mFqY5iFjBrDlJ3o/zz47yfvn2b/m2Z/PMq+//9Pf/3w7ceHfxv8+M3Hf/zj",
	"/3Z/evzxHw//+79mI3eLZbWScjm+OtvGrk9JGXAXfiTQsbPMe1/BpTQsg2c8u6TliOXaNnqhQcR4AS9+",
	"kqx2DpugfzMfUdDAtBdskxW8bNL46ub913M77U9BKtfN4oJt4PFkNF+TBTX5Gl7XzvS2zZapS7pzwa9w",
	"wa/owdY77TbYpgFdunN8IfeiRxG3kYMEAqaQY3hqo1u6hUCCRP2clagPH4+7wctZ2IYn23RRg8tU+LG3",
	"sZURFONvB46UXEvXV2B8FeBYAh7e3ETu7HqwoqliAOhI8T2IprFSpxvhztn9eHUxy+9GSfP87uMtljcc",
	"furyDuUJBKe3jzSLYvEAweDiuMF2IFekYBs6hRqpmFcS4m2JGCqM+RDx2obXqI06mHYwngVxQRCyCU9p",
	"b5o7Q0A2DI9wa0/hIlkqWcHNG0p3EXLyEbmlg4Ltk9Ob1UVxDvHFEk+ILtppZ2C0/Bfb/GLbwqna3hgv",
	"wsXUK9OKcdCTcGHkAY7mdhrTFOa7EXdiPnq3jaE9xPuh2qpjAdnzBpRylZbKyhXwHXLVus7H6LBgVqph",
	"1yxvTBs10dO6BMXQ/XKTfQ1T2ts5Mm5h8Ol2/gE2yo214+jeBDp5lydH61rJS1pmziQwRuOVvHQ0Hpp7",
	"C8I9s2Ppa/bun09fvXHgg/KZUZUFcWZ0VdCu/mJWZfkSqUZIrA8tXFMTNLX999+ZBLjumBGuICKtJzFb",
	"TsshFxLo1kQU3V5nVlh6vnxPI4GzZuESt1i1WB2MWq02Em1aXTsWvaS89GpAD236UcHFtZbEvd+VeIBb",
	"28Mis2Z20JdicLvTt2MHJYpn2BJ6VmEApCbShZgFOReEW9ApAoJWdGPxBo2xQ5Ikmiqzly7TJc/TimKx",
	"0BYlBNo4bWMCjUfEZDuifYvTYzU8Gss20xO863pARnMkN9P7CI7t3UI6J4xG8N8bRnjBhLGfFNzF3vW0",
	"t9GHT99YBEpYQjDM+h6FIJhwH/HHhQPfanFhlJsIQVauGU7qTs2tJ5zdbeQfO9SY5ANAbBd+YnP1ANzn",
	"QVPqsSjY2anoWPb28HqJZxxwGVs8Vtzlc6SiEdxZ/W9wOruzg3hBy4WNj8SqjD21T8efWTv+Hg9s+54C",
	"YPFLipHstNQyMUwjrqgwPh7e7ZbrrRmqtW2vK6m0gQQKST+uvSTFOM7+VvKhzpZK/sHS+tGlxYOr4fTR",
	"xNg7PfhkOa9HGUbkvXAy44iyCxlDpoLbghT0A7cGqs8dBKNOmxzH4358XKMEZkxEiT6Srm/YyCMGtCby",
	"QABh3NvHqEDi8gzS7XSkwzSJip0GT3H8lkQ5mIc6HHq1oPlFWlKwMD1t/W46ljwjie8cslF0z+uERC48",
	"oa1L7FAzVXHTffLai3pTrv9LI0c5r2iZZv8L2P13HYay4CuOiTUazaK0EG4gUksuDGJRwXVd0g16NrVb",
	"83JJHs0j+uZOo+CXXPNFyaDF19hiQTUwZq2aznexy2PCrDU0/2ZC83UjCsUKs3YZS7QkQTIDLVcwqC+Y",
	"uWJMkEfQ7uvvyQNwJdD8kj20u+jY7dmTr7+HVBr4x6PUg+ZS8GwjvwXQX0/+03gMvhQ4hmUV3KhpeoxJ",
	"1MYp/ZbbhF2n3CVo6R6H3XepooKuWNpBr9oBE/aF0wSLXW9fRIFJf4CxJNyk52eGWvqUralep3khBIPk",
	"sqq4qewFMpJoWVl8atMS4KR+OMwghLQ+wOU/gt9GTdI6zPvVp2GEf2rV4F3zE61Yd1vnhGqiGwtzqxt0",
	"BPGEuMwcBZGi3ETaW9gbOxewKpaxBh37ktSKCwPagcYss/9F8jVVNLfk72QM3Gzx92+HIP8A6UsIE7m0",
	"84v9AL/3fVdMM3WZ3no1gvae6XJ9yQMhRVZZilI8dFS+eyuTClRpaJn2U/YUve+mvn3oqZyXHSUbRbem",
	"g240otS3QjyxZcBbomJYz174uPfK7h0zG5VGD9rYE/r57SvHZVRSsa6Se+FDBzr8imJGcXYJLtPpQ7Jj",
	"3vIsVDnpFG4D/ad1cWglgMCW+bucEgQw/G+4HfbneNlj6gQpLy4Yq7lYnS5sH2TVcdQ+k75igmmuxx/Q",
	"1dpijv1sn7xI+wNDkwUrpVjp+8d0D/iIDX3FgCa9fL4L6sHAPsFYBk3HN8a2s1O88QnJcGjb/lO8SMHX",
	"dmdg6VvXdtw11j5jGFzxzIVCoIdT19qM672iYBNgokC2DsjfmnIx4i/LWDHi5cdgxjOpDEc/G8Y+gc+e",
	"4RXThlZ1+pkFJTneRLjVFtDQxUojmuVSFJpoLnJGWC31elcE50jk0bWAyUqu8cmJU4XlUmHOJuApjOxF",
	"1031/d8aR9iFMVNSmjFAgfmIA0ClNIQ2Zs2ECb61DLJn9leC0QEgceCDgiSLvLY03me7omW5mRNuvsJx",
	"vKskJRVTFyUjRjFGrtZSM1IyesnaVKkw2leavLvmhYZEqCW75rlcKVqveU6kKpg6IS+cJR2kIOzk5nt0",
	"QlxclPMNfnctYHmFZCgixevEZXoX72C3iVc8xwe0/zPkF9WsvGT6hLy7kgiEbmNJtWVCOj0WjcGYioIv",
	"lwzuKSwHhCfo136IYIKkr5B6Ngzr1vQJbtu1yIA/HhEiDWoqrsUzbERcIELXGNa7GhVKrB6hSlasmJqj",
	"ShW2nVesjR22vJtUplXYLBn651vKxoVRsmhyhhGrZx18jMDiA5BCFsvImwFwyOfcbeH0yhZPU61ADgzu",
	"I2SzhOyuEM6OXTJFFoyJaKAHSHQiuLShCtxAwCvELZUVD9PEualXihZsmg0XiODP2CNEWvoRLuV+A/xi",
	"2/fZpg5v0nnx06905A1vX5mYlqdo2Sjr9XYscOUFphJWrMTYAchCC23nA8ZqyVimuUhrP5eMAW2nec5q",
	"i85xlQHGLKFCJhZIBYQ6+rfVnrAw/JJhVMMWZiDLaZk3Jfq+bnnpr3Jaqq7JqGRLIy2CxcmnW5Ugt3Mt",
	"wPcW07fifMoSwKgH5Hi4ZGrjWqD05LOl2suhen4Ow+ihrGSXLC3TMIpBRD/KK1JRsQlnYadowZjjfYGr",
	"EiBHXgWM6HjaPzvBLgIfL5PDuu1A2qMY2dwiPueaKS4LnhMufmPuNgey5DEG0y5LYbhoIFu1Yi3c+E4Q",
	"iIfqxzwNMUCNRXUrF3TQOs4LdtU57SLi57pu5trQC4Zg+8gt9zROPVPFNC+aEVWmonkXsv2Q0V3et9Sw",
	"UxWOVh8IL3sUKlzybZeuj8s9tOmd1nCXRulUh/hOIVY0ROUQR6gTnrcuXYRvOSL7SCO9xsmHS4exL5nS",
	"XZ/OSAfIrneMbVt0xsckGkqifmH/WTLvsqNH59sgOW5xzjNfGO8I/ZnzGUns4EiGkQCAvuImX2cjYSy2",
	"LbawMLztS1rDKZGFgFvIlkuWmykwQDwEZh8fhQI/WyieM1pACF4b2oJBLX1QHvwkiR1aR3yN0By40Jat",
	"gVEe7pFGMGDILuT/RU7E/UsJ/wMT6YRr4BkZd/ZptSe2ccjTxntSsmEadiV46EZ3pJaalmkLj5+0YCXd",
	"bJsSGnQnDYytN3Lhm0PtG2YfFPQITrtaR1O7e7Ztctukv+BwPYe3Is5u3D/Jf17SciTi5i2rFdOWYSSU",
	"vPvn01fOljcWd5OPholR46JYDSWjgecf5yDwpEkEusbBd1eVI6nHHHOHQ284+3nQ+2ZOBmMJmqIN9d6V",
	"Q4D+5Z3/SU25M1S3QUfDnXWBaMPQwCkBBO0B9xfhwrtgkNRK4rRdQ28IsobPmNCD+PTVQ+BHs5sViyz4",
	"tqby189nLjtZnJJpp0M711nFVwqITnrU8axqkTYuESCIj12ikoojLOOvYW/fOwvvQdyC14pSfubUGQ0y",
	"aiYOSvOqLtHI6oay72vci+wVRNf6vd29G+WhPbTu3MeK3djAd3jXqpvCsjtgfrsb1b/FM1nVJRt/D2o0",
	"j2NBIXw5IUVDVDrGq1pknjeq1cH1HaV+oSXHmgYa0jQIKWvIy1AbLux/IB5NNgb/z6iy/8GkQd3/IVZF",
	"2RvsUDM4Fy5mLv2PbIx3N5/ZJ7tAgcH1TWV3uGFM6yTl8fCtSVDErY7unTceTqZElXfrvG9vJXxZwZc4",
	"RoAgIOCsof1fmhTMMFVZ3nUtr0jV5Gtwi6cr5r3kwQMFFKe9iTqje2e6brSHMz7qmuY4EDoolVStmCLO",
	"Z4i4hLrB8aiivFcspu8WAKIsTb2/u3z3h0WSgFuKPPgTIQIejAu2OUVmAH6/AeEYDwQYAQzCAe4QpFtF",
	"FcSBKTvw9aLDR2EGsE4sTwD/gPyUhc/dtT35qWHIzdTlwTrgOjSaDdc53dgU722CVLRrmyoMDDd3nIc3",
	"iyk8fDqVj+0OQgRuiE+vlZCi7ksEwHW6Mdy8yVPv5ontV+EDoqQho6Erk5fLqpIClEVl2bPUiYKA75KG",
	"unmCMHHJSlmzZGvYJBIdHMTjKLZqSooWKi4EU51OU5yPNV8JVphrgV4NZ/Dnu2uRahs/19A62o5UHtGo",
	"BsTNEuz2EsahEzjWNL3piK2bdjuiL6d78xFfoC9pGBGGWjJ1mzHfuTEm5G5cCYXxh+hMzb1rETBaeMK9",
	"0lje3cjndPRO08EKy35vaOmszAJsuu/AcTi/YALTNYZqskYSJnSjnFHXwgrjWVDcMDJ+pHXb5KaJG7Nt",
	"ydAUKLyDLt25koETPHa17ENhD0duTwZn23OxyrbEBuUQHOQa+uBP0FJtzctnB7dIqCpWTAz6j21aEADn",
	"+2+JEMKckm0hlnRoWFSaTwxTZJAHL58/JJD/ZiwTSVRpbfey4ySP0yBC/8QBLP1QwH2gWDI2Zkjs+V6Q",
	"JRt5nHalcVpethmcoFVf+bsTyonOZD9SDSmZXHNn9P5MPcg6QLoya8Oh4tDlvdP8zGcrJZu0w9EKw+l7",
	"rpDA3APjhG4wek2/+/qb02+++zsp+Ippc0L+A/E++PgOU9x1T5PwNnVeJ0MnAcBCvCyyP87XIZpz7Q50",
	"4NPCnc8DDHP/J3yT7BLzGfAlmblO+WW9HPAspHYOIhDqGdGbjsL9EN5YXBhFkfhmcrlMhj//G35v1UHK",
	"02TFhqc+gSpjIcMbcgX/wiqIH+ezHfnUysuQSu1mhKdkY/lPy+vE9Xn8TdbeoBPyyvYmTCylstJy1RjL",
	"A0DhZq+v7HCpEC9j2lzQECoj/mBKgjJAEGll//4byKPNBv8OmgM/r52TkoUhxDkHT/IHZ8DNzBHIhyhr",
	"Dq8aaYThyP7Ybfwl2sXaPjwW6P+seZnAglra7zqGY06EJFjlIG6J3nht3BfC7HytO4h0v9c8zvVQpHVd",
	"FhMKzJvTpkhqNQ35moo2bfvuhDpDnNynYGOX9vev+SET/2yB89Nm/hFyxDFFuPSGVkCBCKygFbtfgGu6",
	"qZgwN6R8b7A3+rxgdfntEoAakQB8711JoMdqPtux7ccQARxELdB/IrWN1jgfkXuCdd8nvG95V7xBlkVY",
	"NuA3Gbmaev2nE+mCHv2CbYjyqoE4k2xb8HhPKQufRcNTEUrveMVauQQZuRQLxCc9iShepuVadJpHkv3V",
	"luW0ZaK3YoUewQpfHnobToRT2ANtz0KfbhHkoTZsU7OuC0Anx3XX5xVk/BPyPPgig70EvfJaB2XUP/Wt",
	"KhjRGwKsufJ6Kqq83hgML+fn72v0iEhcXNcAeRnbZsjVuCY0X65CpYyE4sY3u14y1bZLKU98y6X6o204",
	"1Nv4ZsMiKx3KMz9Efen0HXLHnMEECf+2WVdw7PBy4TK02LJDCbk1Panz2gHDS/Sw7ashjHXTmKSg/eEZ",
	"Lct31wJnSjiRtBWYU2ZDzPjr4jECkbSU1FkOveLIXdDYyEHz3HJZRevvGcH5lSb9vFLoBTrMLNV5xPck",
	"kok6OAHdqFqNrht0RkNOkOeEqlVToV7+7te3YwWj2VR54ULBhilBHdeEN71RrCBSuSAQvnQRPmM5bSbm",
	"+cP6QVC1vuXOWhfUEUyfW/mD1S7jghRZHoza9qmyQp6R5ByNweezE/ISHcYVowXSTMUNS2Wc66wfolev",
	"WFmCSh8xOgunG+UTPbG3qJPRTwNmKwZlghI5Jr/UHIa01s3IiY1RJWRsuof0CU7omZ2pzR2Ph5RTIaT5",
	"gs5pzxyGvUJpkQtHXYdkhiUTvl4fsr4w7IiaVCrGV2JbcaMl9Q+B7h9X8jnoUikXqBYfvB68EoEjvhkR",
	"BeMHDoY1TGiRSVFuUtQ1DkrskdewF1srHIUwRd26/Wi3yigjzrQlejLzJlohIDZIzW8Ou74bpJy8dZ7J",
	"3gAdqrGrb8e3aWcJ++7QuzizyNC4lTPD9CylXTjSJ8Uy/356iiUKzNzStK5S5+Ip+YMp6eTFMJS9EK16",
	"2oXvu8jak0SnkGZJD7r1p9wzjRUufgt3OJoK7/z8/TUdcBkA0y34i5tlNdx5xi9G0gjFZ+ytVS5v0C3z",
	"g+GMWzZ2rH7n+fn7JS2KXkaV2H0KiUzICIK77fIpAbLQq5HURVtPc7n1NLeM3wm/uPIC35YaS15AxECX",
	"K7/j2CPlUjruHtlmnBtOPeXyB/v9JNTwQu9tkcPPugU9tmS6pBXIZE9DEmMHnAzwnRBHQpyt2/+uvCql",
	"XHpq5s1j3oDbK3KFhdtJReuD5tHcSTwiiMfN/mzU6N8GNbmH2Y8X5WuAAVrvgn4prdvV7POjp08QvvZD",
	"WWiczKUt36lYBXFYrYiZOByXBC6whW12PnSkAL+H2L1bRzPEe03ISzsyLa/oRntVaYtY48P5XcWsLwk1",
	"XRyoifrd9N6oHAxjb1nOaw4VSbtUMOD4uIJxpCIsKiot0cEIMn4ZlBbOv5u2aRW7xi9v+3IJ4mj0QM/d",
	"NtOyqy3Agb0y2LZ55sf2KwpHGr1nE6qpJdJthi3dQfOcdXIrsXOawn1pHPZCIofTjFM30S98NGIWEbaR",
	"PbTXVF103kCqu9UYMZChM2qHxYjCD25Qis0ZE960tabAnTqo9n9hCg2Yb6koZEVeNAKx4MEvb188dFXa",
	"PZL51AUW+Rwkn2mVtlot3crPerXZvDc52jRWXBuV0Ft+vpXblsPKbYn6ZXZ1h6rZdlF8oppt5aBm281X",
	"Or1am78xY7XaPksE2iFJeAPndurpbDH7kk/XDemnm+lm7CFyhyM1+03IWdV7+G/FZHUq2FJDriz3oV3e",
	"0ZbZ6jp1thmARfDNjOwIO50+u+ONlGZxfBZMAokLE4VPtSuo69+WqHQ6VtbCzMVlxPwsG1Ho3ha21UK2",
	"WEC38j6O9fFtthpTx5iCqZzAWWwq7UICpkgXzhEK9/YLAkE2WcwbC8WTsW5vPxVUu5W1kpe8SNXpKOWK",
	"5xo1MPvabF/5vh/ns6opDb/hOK99XzQip59DvnJPoSioKggrvvnuu6+/b5f7mZGr4SYlHWzcspySkRqe",
	"d/nYsLoJRMwf5clKDknWqK1NrVrTQ7CtzSH/deu/tp+JDABJrzdarHfRWGwIjVBdWra9NLz9aW5/W1O9",
	"bklnlMMccstT4uhV3+8OInc+TUGo6FJkt3KN6F2PMcLRXpLP4W706qXxfDJJfB1RkmGKb7dEVLtafPHh",
	"jLDXdcksb9fSwOG9ydWmNvLUHw0++X7OMz4sexKPl951aAA5S6XlRDDJgWUmW44LFAQtVDfwzx3sz1kM",
	"VyqV4loxbSFK+9Os1fn5r2lmcyzy33KX6U4f9zzbs96edncc922Uw60vEIh7ltm248D9gzTc84/gsr0E",
	"biyXwtAc+EZMoj176hRmM5ezebY2ptZPTk+vrq5OvDbtJJfV6QrCTjIjm3x96gfCyk1xMLfr4rIdWipc",
	"bgzPNXn65iXwTNyUDDzYC3YNWruAWbNvTh5hDgAmaM1nT2aPTx6dfI07tgYkOMV8G7MnHz7OZ6eX35zG",
	"rjKrZCEuRlW+RkHAtT2BeHaG0s3LIjR6IdVTP5wze2Ap4ifvx4oO2Str//69YWoz85nwYzVQa4wbXo/d",
	"kcqoptDogmkahbHfipHcM3GRpRlL5bFLJghHtq/kFQ8FMJQVat2rnYAZ2u4JcJsWi65YBO8J+VmzKPek",
	"vIAgEGQ3vUu5T50YOo0AZodIwdWi/DBMF3fNsbrg4UeF17yvIOwJjCYich096eR1c6paVwjDpd3IN6QR",
	"peUvvPkBrIY6LA1S/mFGipy6HXDxVt5vVY+fgJ8kcxBmFsI9T8RlRwfZCB4T52kLWi4nOjkcn4cUIrHf",
	"wLwtouYU9XMSknL0NMxzZ/f3NZKHpYfRq2Bswc4JOKNlmVpmZGva74RLVzrnMz1eO8WtztZ7/EXmXFcv",
	"B9YLeTrtgV+wzRgwbWDs+M3a6ce3/fMY+J6meSt6W/0E0x1CEuSaKRhS5KDI14CZXkuGdNk7chRc00UJ",
	"BQFQBO54AYwiX8jRuscJxKlKxol/3/9hywy/QhEPSBoFT9g3jx75d9qptaLRTn/TyIC1A477je4TCJJi",
	"FH0GvK1BtiF5Mdpb8Fyv8H2q6saM26SvTQavwnDkn7XzcqvpigvnyQHKoopegE5IYEiQc6Tyt9PHVNun",
	"JlgB3OPkMGaCzqZ9/7sb8GuSr+pC/gAcKh7aBX57q3MczRY2nrWrtw7fcArYbx0CojMoZhv7OJ9996Uv",
	"wSI1XVnubaaBv5v9+rHHNZ5+8J6MvPg4ykK+kvKiqYMuMq58MeAksa27Vz9sgEhs5SSDhtPTXCApluGN",
	"KEoAchbvkVEN24svmkqBD0gx/5z8yJ2Q7T2I9R0S5zRBPNLD2bePvj2S9M+HpJdAaHeQ9NN+dZMp9L1v",
	"7txC4ONaI7sI/VG4P4xwH+U4sbMs+bUjc96vJ5e9HHcCMiBzV3g6CQVY0mGwveUhtImMiUPh64fkxD5c",
	"LZ70ACF2qW3jq3eb2u5DCV7wv9nd8hjYtJbewAr4IMqg4oQAR81XJAsGN/tLhT+BEveMr+xPJf4E5iNU",
	"nqfWrvlqfPEaulX4jx1v0iLdTY4W0rWcLTYuc0r6LNLS2mfJT/kpqSFSRWUI2qkr7hL/j00fGhwEBMzZ",
	"3oeBXu+AwTfYVxC/E/1rf2XRmrCqleEVOyGvHaGhgrx98Yw8fvz4e1ek1TKviC5jC8YhMUA8Bi4QjIKa",
	"8HkK+Xn74hkAcBZsEpNa7TzUgFGHWjmM+Pkt/C+sK/5LKlE/pbyNq3ZSphPLMGPGdvYk5NW4R6H0L6L/",
	"GxZAvH2KrJFaIv6d60x41Cv+qYTQSHE1ySIdtx83SndbbTdMH9pC8Ve1MB7F9RuJ6wfWjPbu0zSjVjf5",
	"8dGw1QvKvrVx609tGYr26fRDl1DuthB1s9EnFYdtk7R1KMWO9sn1Tpb0aJA5FNnZk9jcn2HmluaYoy3j",
	"C2EjB0To1CfmnEiJiG0/gRy9kiv9aUjSkdU6jGXkE2u//6KqaAi1CjqdQTYu9Mhz8XNt6FjSIIKpONtU",
	"GnfjmHdnb+V45ruaF9e9vJJYmGAklPAuWfRSrjJP/veVJ17J1XOaTpf8JXD+SKpvwTlse7NCaq6dSg9o",
	"uc0JH4faoek46iGOj+Mer9ULsHuj2dtnhvNXCk1cIU/Kdirtmh16djv66Gppz2h2gPkawc3YfPbbfvMd",
	"xB574IcpEKRpVN42P+qLwqvhafDRDfpPrOyCQz794K/nbgWXy0i22wHaNpwuTcZZk46qrTtVbWlXr2cS",
	"LbxHP2OY8khujpq5z1sz16eYp67E8k6NHLLevZT9V2sJBCUu9r6VovrJjrLRUTY6nGz0CfxYj253f3a3",
	"u4PxeYdlgGJ6PUkwfM0FB+L7I9K7o4wYin+3r9FRSvwr8Tz7RFV1LCJx5u6touMxsOoYWHUMrDoGVh0D",
	"q+7Zmn0MgTqGQB1lsT93CNQUjxWfSJWLOI1wTPJdodQxVL9jJ5bBop7JasEFa6UZv4I2X5SR9qCgUVwl",
	"1jeEKizeS2HHujIly5H31VciDVmf5zNfb5UqyylPeW87q/EAQs7raP64qNlea4OCG6CwIz70DHFZ2H0u",
	"yw0xcKUKqPUXkl/PLYO8kQ25gstS8gvoDwXqMZ6twnKD3TRdUKukGTVuu+5ZKM+ySwd49wakY7zeMV7v",
	"GK/3F1BtQA12ffoBq7ajAmGnERw6jWkvfrAfd2ks8DLidOkI5Big+9WWbrtFuLhjaMEXjPGTVHeRs+b2",
	"ZEjBZfOorzvq6476uqO+7qivOyZCOmoBj1rAoxbwqAU8agGPWsC70wJ+Ss3dl1YX4KgbPOoGj5qSPYNj",
	"OlUUP1iZaHd4DLHiYzkoVJ9SFMZYNyVGxgll07MRfkEkJNquvS7r9Mt5jCQ5kpfPRREL9e7Vpb/r3bJ7",
	"7JpWdcmg4h6kanD9Q8G+XFYVPFThFzdy9IsjZR9//fj/AgAA//9RvRdQIR8BAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
