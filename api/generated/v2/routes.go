// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9fW/cNtYo/lWI+T3AJvsb2WmzXdwGWDxIkw022LQbxG4XuHEvHo7EmWEtkSpJ2Z7m",
	"+rtf8BySoiRKM2OPnXQ7fyUe8eWQPOfwvPPTLJdVLQUTRs9efJrVVNGKGabgL5rnshEm44X9q2A6V7w2",
	"XIrZC/+NaKO4WM3mM25/ralZz+YzQSvWtrH95zPFfm24YsXshVENm890vmYVtQObTW1bu5Fub+czWhSK",
	"aT2c9V+i3BAu8rIpGDGKCk1z+0mTa27WxKy5Jq4z4YJIwYhcErPuNCZLzspCn3igf22Y2kRQu8nHQZzP",
	"bjJarqSiosiWUlXUzF7MXrp+t1s/uxkyJUs2XOMrWS24YH5FLCwoHA4xkhRsCY3W1BALnV2nb2gk0Yyq",
	"fE2WUm1ZJgIRr5WJppq9+DjTTBRMwcnljF/Bf5eKsd9YZqhaMTP7eZ46u6VhKjO8SiztrTs5xXRTGk2g",
	"Laxxxa+YILbXCfm+0YYsGKGCfHjzijx//vxbgttoWOEQbnRV7ezxmsIpFNQw/3mXQ/3w5hXMf+YWuGsr",
	"Wtclz6ldd5J8XrbfydvXY4vpDpJASC4MWzGFG681S9PqS/tlYhrfcdsEjVlnFm3GD9ZRvCa5FEu+ahQr",
	"LDY2miFt6pqJgosVuWSb0SMM0zwcBS7YUiq2I5Zi44OiaTz/Z8XTvFGKiXyTrRSjQDprKoZb8sFthV7L",
	"pizIml7BumkFd4DrS2xfPOcrWjZ2i3iu5MtyJTWhbgcLtqRNaYifmDSitDzLjubwkHBNaiWveMGKuWXj",
	"12uer0lONQ4B7cg1L0u7/Y1mxdg2p1e3Bc1DJwvXnfYDFvTlbka7ri07wW6AELK8lJplRm65q/z1Q0VB",
	"4tulvbj0fjcXOV8zApPbD3hrw94Ji9BluSEGzrUgVBNK/D01J3xJNrIh13A4Jb+E/m41dtcqYjcNDqdz",
	"qVrJZGz7BpuR2LyFlCWjAjbPSSkZLcsJflmWhBtWaSfUWNYIExSBlc5JwUoGi2yvA/hVGyU3sHjNbDtZ",
	"G1ZksjEOKdaytAPqOZwIDoufo8unlDkttaGGjQpE8Uq2LLrkFTfD5X5Pb3jVVEQ01YIpe+CetxpJFDON",
	"EnDYipEczmwBUg+33WlJarpimjDLejlKczCPJQ0hDVGM5utxvEeYtqB6RW8yJRtR7CC0GCJVfCnomuV8",
	"yVlBwihjsLTTbIOHi/3gaUWpCBw/yCg4YZYt4Ah2kzhWS572CxxQdKon5EfHneCrkZdMBCZGFhv4VCt2",
	"xWWjQ6cRGGHqaXVBSMOyWrElvxkCeea2w3IIbONYaOXu71wKQ7lgheWuALQ0DLnNKEzRhPsKKQuq2V//",
	"MnZDt18Vu2SbJNPtIwAuJ2hFa/sF+06vIsywhah3xMOl7OPfJO7thHfQKEO2kbiF7VfHVNIaaKf/Djpo",
	"PDfqP9m9dFEcw19vY1vRm+nhxF7NVxmOOKASvjq3d/GSl3BP/2KJw59so+291D1bf3NrvhLUNIq9uBB/",
	"tn+RjJwZKgqqCvtLhT9935SGn/GV/anEn97JFc/P+GpsUzysSd0UulX4jx0vrYuam7Dc1BT+c2qGmtqG",
	"l2yjmJ2D5kv452YJiESX6rcZanljM6cUsXdSXjZ1vJN5xzCx2JC3r8ewBIacYoTANHQthWaAri9Rgvjg",
	"frM/WV7HBLDySAg4/UVLEHLbsWsla6YMZ7EhyP73vxRbzl7M/r/T1nB0it30qZuw1SvM2B2GlEuN413I",
	"sxw3QymgqhuDd3qKLQQ6/hhg68/ZHotc/MJygxvUBeMJq2qzeWoBdrDrw+0W/B+Euz32zYFMlaKbB95H",
	"vNUzuJ2HI/9oZVDL0mu64gIWPifXayZIRS8tO6BCmjVTxJ4F08bf78j38MoPFiwnJDhJ+2SWopjEmep7",
	"H2p7au/k6iBnu8Wuc3HxkdY1L24uLn7uyNlcFOwmfQwPesalXGUFNXR3ZOzs2WvbNYGXXy7q9G1mh0Kg",
	"wyLPHqfwuOz0UNt1YGLTd8HfI0NNUMX9marWzHxHSypydohTXrihdj7h77ngAMQ/0MBxPGZ/zGErD3HE",
	"hyBgO85WgoVGjyszwpSH2CR9qF3ag8H5/TrifDjLe2P8d6XML+90llNHBaNumfkfjJZm/WrNHmD+aOwt",
	"UJy3WugBMPpBMTFSmLetP1rVFkGnO+yeyBNNo7/03fty6Liz5buzv86Z9png7mes9zvkW294iS0rCU+7",
	"i4rhAs1vVvOjhlDnOEaD6IW4EK/Zkgvwb7y4EFY/O11QzXN92mimnHB1spLkBXFDWkXsQszm/btjzDoJ",
	"vkEHTd0sSp6TS7ZJnQI6LdOqbLmSVpE10tAy8t5ErkxnM2+tMEOUwwkyixmyMZkLAcgUu6aqSICug8Ue",
	"Rkaf6tSsc+LGRseCCzFw46fJgNa1zsD3lYHza0yTL3t6vEaHGbFHRrSRyrsNuPbQwPn+II0zxdNrgvhF",
	"Gs00+Z+K1h+5MD+T7KJ59uw5Iy/r+p0d88zC8T/OjG7paVOjM3Jvrd0PlhISYOFwnhm7MYpm4FxLLt8w",
	"WsPprxnRTQV+2rIk0K1j26iVXClaOT9dWIDfj/EDQDh2u8uiFcLizrCXD3xJLwE+wRFCG7JmpXNA3eO8",
	"ItXjzse1RX2ZCLW5uPgIUTT+ZILXfUW50P5W0HwlLBG4AIUFI7mVAlhxQt4uCXC1eae7C5NzHDOwDq4x",
	"poCc2zWCO4nkVECsQV2A750LQsWmb8fWzBjvNfjALtnmPPJG7enVcK5ruuVKLBo7XLgW2xMm11STSoJH",
	"I2fClBvnDU+gZhqYhguDbrkcIw4yi79jTAOoJgp6sIQTsxA3Rh8RoxgAWtdkVcqF4zQBRV8EHPV9xpnK",
	"ewuAPgBDSeoafhsmaK+mKrERSIgjW3CHhdrx7kWGk8u7M8otudIQacGouyNoTCJ3wDwXBjIE5d9rBlKZ",
	"VBAO0UUp7Uk6hfTByzuf1VQZnvN6N+skjv6+08cOsu1qT17mctm/swdXavIKwcbZgur09c3sF4uBjcYQ",
	"IbtGz+j8TCgtwwpOCLh0HakuSogaChGNeMZUQTiTXzZG+I2BlqYLpkQrU3kwujsSC29rqn1kEwSAeRax",
	"k5gzgrzndgMAgS3dRNgby63czluyKzq2/+Pe5LeisLyD6W6UV/AV+2ulT/7zEJSBkdvep+wdyd57PJvv",
	"5Qmez6yM16SPQwqQ8Sx1rXDh2NgjigPtTzo6IAvHv5bLkgtGMsLDag2sFqPyZM4xNK2lRDcHsyrAn4nF",
	"NjvAziOk0DgCu5ayxIHJDzKmTbHaB0jBOHAT6scGthL9zXawyYRIBqdcbFUChryjJaJ5GyuCxzjU3IL/",
	"9n2fjSX1s04rgk0WTt+IrqsUilrWlFsFX+gGIjONzGV5MlDMNCsZcPqsw1kzq4QlZToGaHjmu0VKG3nC",
	"l1bEehqxcsVWXBumnMIOEIZwmzaaaGOYhYwaw5Sd6P88+e8XH19m/5tmvz3Lvv3/T3/+9Jfbp38e/Pj1",
	"7d/+9n+7Pz2//dvT//6vlP54JQ3L4LrLrmg54hS1jd5oEMXfwM2YZD+drSIYOstHDBkw7SXbZAUvm/Rp",
	"u3n/+dpO+0PQXnWzuGQbuGQYzddkQU2+hluoM71tMzF1Sbcu+B0u+B092Hp3wyXb1E6spDS9OX4nWNXj",
	"J1PElEDAFHIMT210SyfYC2ier1mJ/vTxlA6wKViGaejJlM1mQEyFH3tK/IqgGOe8OFJyLV039PgqIGYB",
	"goe5iSKl9WBFu4rLYEtEbhpNY7UzN8KDi8Xx6mLR2I2Slo3dx3ssbzj8rss7VJAJnN4+Wh+qjwMEA8Jx",
	"g21BrsgQNYw3NFIxb0xDaonEEUwnEPHahmTUBrTvdjD+Anfx9bIJQlRvmgdDQDaMvHdrT+EiWSpZAeUN",
	"taAIOfmIfN9BwfbK6c3qEgSH+GKZJySubLXHM1r+k21+sm3hVG1vTEXgYleSadUd6Em4MPIAR3M/y2IK",
	"892IWzEfA6fG0B5SydC80/EU7EkBpVyldZpyBXKHXLVR2TE6LJjVCdgNyxvTBuT3rBPBgPK40mTfEpMO",
	"pI2cQJjXOC0/wEa5sbYc3fvAJx/y5GhdK3lFy8yZzsd4vJJXjsdDc29pf2RxLE1m539/+e69Ax+MtIwq",
	"dKZMrgra1b+bVVm5RKoRFuuz1qxG7S2a/fvfmc657pjbryHZqadvWknLIRcy6NaVElGvM78vvVy+pzHd",
	"eX1wiRPeH1YH509rtUPfT9ffQ68oL725zEObvlRwca3Hbe97JR7g3n6jyP2XHfSmGFB3mjq2cKJ4homs",
	"pgpz6zSRLnsp6Lmg3ILtDRC0ohuLN+i0HLIk0VSZJbpMlzxPG1TFQluUEOgLtI0JNB5Rk+2I9i5Oj9Xw",
	"aCzbTO8QuNUDMpojuZk+/Gxs7xbSBSs0gv/aMMILJoz9pIAWe+RpqdFn5t5ZBUp4DDCD9xGVIJhwH/XH",
	"ZZrea3FhlLsoQVavGU7qTs2tJ5zdffQfO9SY5gNATCs/sVt3AO7rYGf0WBT80VR0PGB7RIfEMw6kjInI",
	"Dkd8jlU0gjvv+B1OZ3vhCa9ouYzkkTSIsav25fg1a8ff44Jt71MALL5JMUmallomhmnENRXGp1q73XK9",
	"NUOjsO11LZU2kJufjHfaS1OMU7jvpR/qbKnkbyxtH11aPLgeTh9NjL3Tg++s5/U4w4i+F05mHFG2IWNI",
	"gr8vSME+cG+g+tJBcIm0dVc87sfHNcpgxlSU6CPpxlCNXGLAayJPPSjj3rtEBTKXV1DJpaMdpllUHFx3",
	"iuO3LMrBPLTh0OsFzS/TmoKF6WUbn9LxgxlJfOdQ6KB7XickCnUJbV3NgJqpipvuldcS6l2l/t8bO8p5",
	"Rcu0+F/A7p93BMqCrzjWbGg0iyoOuIFILbkwiEUF13VJNxgB1G7N2yV5No/4mzuNgl9xzRclgxZfYYsF",
	"1SCYtWY638Uujwmz1tD86x2arxtRKFaYtSuGoSUJmhlYuYLjecHMNWOCPIN2X31LnoDLXfMr9tTuohO3",
	"Zy+++haqNOAfz1IXmqvuMsV+C+C/nv2n8RhiDnAMKyq4UdP8GOtzjXP6CWrCrrvQErR0l8N2WqqooCuW",
	"DmSrtsCEfeE0wWPX2xdRYD0ZECwJN+n5maGWP2VrqtdpWQjBILmsKm4qS0BGEi0ri09txjtO6ofD4jTI",
	"6wNc/iPEN9QkbcN8XHsaJo+nVg1RKD/QinW3dU6oJrqxMLe2QccQT4gr+lAQKcpNZL2FvbFzgahiBWuw",
	"sS9JrbgwYB1ozDL7XyRfU0Vzy/5OxsDNFn/9yxDk76AyBmEil3Z+sR/gj77vimmmrtJbr0bQ3gtdri95",
	"IqTIKstRiqeOy3epMmlAlYaW6Xhez9H74dzTQ+8qedlRslF0azroRiNOfS/EExMD3hMVw3r2wse9V/bo",
	"mNmoNHrQxp7Qjx/eOSmjkop1jdwLH2LfkVcUM4qzKwgtTh+SHfOeZ6HKnU7hPtB/3hCHVgMIYpmn5ZQi",
	"gJllw+2wP8fLHjMnSHl5yVjNxep0YfugqI6j9oX0FRNMcz1+ga7WFnPsZ3vlRdYfGJosWCnFSj8+pnvA",
	"R3zoKwY86e3rbVAPBva1qzJoOr4xtp2d4r2vdYVD2/af40YKMalbcxY/uLbjIaT2GsMkhFcuZQAjnLre",
	"ZlzvNQWfABMFinXA/taUi5G4UsaKkRg5BjOeSWU4xtkw9hki3gyvmDa0qtPXLBjJkRKBqi2goYvVRjTL",
	"pSg00VzkjLBa6vW2TMeRDJ0bAZOVXOOVE1ehyqXCckAgUxjZy0LbNUZ+Mt+uC2OmpDRjgILwESdKSmkI",
	"bcyaCRMiUxkUZuyvBKPoQePACwVZFvne8nhfSImW5WZOuPkTjgOxb3AfV0xdlowYxRi5XkvNSMnoFWur",
	"cMJof9Lk/IYXGmpsluyG53KlaL3mOZGqYOqEvHGedNCCsJOb79kJcflDLrL2/EbA8grJUEWK14nL9KHQ",
	"wW8Tr3iOF2j/ZyhdqVl5xfQJOb+WCIRucy61FUI6PRaNwdyDgi+XDOgUlgPKE/RrP0QwQT1RqGoahnVr",
	"+gzUdiMykI9HlEiDloob8QobERew33WG9UijQo3VI1TJihVTczSpwrbzirU5tlZ2k8q0Bpslwzh2y9m4",
	"MEoWTc4ws/Osg48RWHwAUiiQGEUzAA75cq4tnN7Y4nmqVchBwH2GYpaQ3RXC2bErpsiCMREN9ASZTgSX",
	"NlRBGAhEhbilsuJpmjk39UrRgu3mwwUm+CP2CBmJfoQrud8AP9n2fbGpI5t0bvz0LR3FkttbJublKV42",
	"Knp9GEvweINVahUrMfIeCpxC2/lAsFoylmku0tbPJWPA22mes9qic1zAnjHLqFCIBVYBKYH+brUnLAy/",
	"YpgTMCEMZDkt86bE2NeJm/46p6XquoxKtjTSIlhc17g1CXI71wJib7EyKM6nLAOMeliKsmi6cS1Qe/KF",
	"OC1xqF6cwzDLJivZFUvrNIxiss0/5DWpqNiEs7BTtGDMkV6AVALkKKuAEx1P+0en2EXgIzE5rJsG0h7F",
	"yOYW8TnXTHFZ8Jxw8Qtz1BzYkscYrOgrheGigULIirVw4z1BIG+onxs0xAA1lv1sP3QD5wW77px2Eclz",
	"3TBzbeglQ7B9hpO7Gnc9U8U0L5oRU6aieRey/ZDREe8HatipCkerD4SXPQ4ViHyK6Pq43EOb3mkNd2mU",
	"T3WY7y7MioacFuIYdSLy1pVV8C1HdB9ppLc4+bTiMPYVU7ob0xnZANnNlrFti874WGxCSbQv7D9L5kN2",
	"9Oh8G2THLc554QvzAqE/czEjiR0cqcQRANDX3OTrbCSNxbbFFhaGD31NazglihBAhWy5ZLnZBQbIh8DC",
	"1qNQ4GcLxWtGC0hga1NbMKmlD8qTHySxQ+tIrhGagxTaijUwytM9KtQFDNmG/D/JHXH/SsL/wEW6Axl4",
	"QcadfdrsiW0c8rR5kZRsmIZdCRG6EY3UUtMy7eHxkxaspJupKaFBd9Ig2HonF9451N5h9kLBiOB0qHU0",
	"taOzqcltk/6CA3kOqSIunNs/yb8rJVVcVafn9BaE2RbEl75FrUbWrnY8uGNC4YHuAfq6mIM5K6Y1XbF0",
	"tfEYF33DFAr+/YqWI6lCH1itmLaSLqHk/O8v3zkn5FjCUD6a30aNS141lIxmlt/OQVNL8zaM6YPv7qWK",
	"pAF2LI4Pw/js50Hvu0VHjFVgijbUh4UOAfqnz1ogNeXOw95mSw131mXQDXMad8l8aA+4vwiXlwaDpFYS",
	"1+UaYjRZw2es2BHweg/0LRZZCMpN1XSfz4BkujWXtkbic51VfKWAW6ZHHSebyIy4hbt3YO9N2s7gx0tt",
	"7qA8ZGKHNa/qEt26TkawN3rci+yVttdG2j184OahY8IePKqL3dmlePhgrrvCsj3BfTpw61/ilazqko0z",
	"8hod8vg6Dt7VUDwhegfFG3dknjeqtfr1Q7N+oiXHAv0aCigIKWv7r70Thf0PZMDJxuD/GVX2P1jOp/s/",
	"xKqo2oIdagbnwsXMFeaRjfEB7jMrJBSoori+qWoMd8yi3clcPbwkEqxsMrS+cznDyZRoZG/TBSxVwpcV",
	"fImzEggCAuEh2v+lScEMU5WVltfymlRNvoZAfLpiPi4fYl7AVNubqDO6D9/r5pc4d6euaY4DYUhUSdWK",
	"KeKilIirDhtCnSrKey+f9AMRQHmmqYtzW7bA8MUfEHOinIFEUoIH45JtTvEWh9/vwDjGUw9GAIMEhAcE",
	"6V55DHEqzBZ8vewIQFibq5M9FMA/oCBk4XO0tqcgNEzy2XV5sA4gh0az4Tp3d2/Fe5tgFe3adpXih5s7",
	"LnybxS7Cd7rIju0O0j9uiC98ldDbHkt2x3W6Mdy8yVPvVnDtPykHTElDrUH35lsuq0oKME+VZc83KAoC",
	"0VIaHoEThIkrVsqaJVvDJpHo4CADSLFVU1L0iXEhmOp02iXcWfOVYIW5ERhHcQZ/nt+IVNv4uobW0Xak",
	"KnxGDxrcrfRtr5Qbhp3jA513HbENDG9H9G/D3n3ENxi9GkaEoZZM3WfMczfGDlUVV0JhxiOGb3MfzASC",
	"Fp5w750nH+Dkqy36MO3g92W/NrR0fm0BXuRzCFXOL5nAQorhaVQjCRO6Uc6NbGGF8SwobhgZX9K6bXLX",
	"korZVJkyBSb2YL13wWsQdo9drfhQ2MOR02XabHsuVtlENlIO6UiuoU83BbvYZMU8O7hFQlWxYscyA7EX",
	"DVLufP+JnCSs9ti+KpJORovemRPDohzkydvXTwlU3BmrfRI9G7Z92XH5xd0gwojIASz95MN9oFgyNua6",
	"7EV7kCUbuZy2FY5aXrU1o6BV39y8Fcodw9f+QTUUgXLNnZv9C41Z6wDp3gwbDhUnS+9dWGg+WynZpEOc",
	"VpjA3wu+BOEeBCcMvNFr+s1XX59+/c1fScFXTJsT8m/IMMLLd1iSrnuahLel7jq1MwkAFjJ0Ufxx0RXR",
	"nGt3oIMoGu6iLGCYxz/hu9SzmM9ALsnMTSoS7O1AZiG1C0mB5NKI33RM/IeI/+LCKIrMN5PLZTLh+l/w",
	"e2sOUp4nKzY89R24Mr7Kd0ep4J/4pN/tfLalglt5FYq33Y3xlGysMml5kyCf519nLQWdkHe2N2FiKZXV",
	"lqvGWBkAXiH29sqOlAoZOqat0gzJOeI3piQYAwSRVvfv34E82myIKKE5yPPahUVZGEJmdYhdf3IG0swc",
	"gXyKuuaQ1EgjDEfxx27jT9Eu1vbisUD/e83LBBbU0n7XMRxzIiTB9wfilhj/12aaIcwuuruDSI9L5nF1",
	"iSJt67KYUGClnrYoU2tpyNdUtAXVt5fwGeLkPq8Pdnl/n8wPWWpoAs7PW2tIyJFQGOEKKloFBXK+glXs",
	"cQGu6aZiwtyR873H3hhlg0+lT2sAakQD8L23lWcee8DYjm0/hpzjoGqB/RO5bbTG+Yje0z5770rRt7Ir",
	"UpAVEZYNRGpGwa3e/ulUumBHv2QborxpIK782r7eu6eWhdei4amcqHNesVYvQUEuJQLxna5EVC/Tei2G",
	"6SPL/tPEcto3jyexQo9ghX/reAonwinsgbZnoU/3Rd+hNWxTs27QQaf6dDfKFnT8E/I6RD+DvwTjANuQ",
	"aLQ/9b0qmEMcUrq58nYqqrzdGBwvFxcfa4zBSBCua4CyjG0zlGpcE5ovV+ENi4Thxje7WTLVtksZT3zL",
	"pfqtbTi02/hmw+dPOpxnfojHktM05I45gwkSEXWzruLYkeUCMbTYssUIOVkQ1cUJgeMlutj2tRDGtmks",
	"i9D+8IqW5fmNwJkS0R/tc8IptyHWGHYZIIFJWk7qPIfecOQINHZy0Dy3UlbRRphGcP5Jk34lK4w7Hday",
	"6lziezLJxAs1Ad2oWo2uG2xGQ0mQ54SqVVOhXf7h17dlBaP1W3nhks+GRUid1ISU3ihWEKlc2glfupyi",
	"sSo6O1YWxJd94An2Vjprg15HMH1u9Q9WuxoPUmR5cGoTeO0eMucv0Bl8MTshbzFEXTFaIM9U3LBUjbvO",
	"+iFf9pqVJZj0EaOzcLpRBdMTS0WdGoIaMFsxeMAnUdXy91o1kda6GTmxMa7kAuE6h/QZTuiVncmNFA4p",
	"p0JI8zs6pz2rJvaeMItCOOo6lE8smfAv6aHoC8OOmEmlYnwlpp4dWlJ/Eej+cSWvgy6Xcqlx8cHrwS0R",
	"JOK7MVFwfuBg+LoILTIpyk2Ku8ZpkD32GvZi8u2hkBip27Af7VYZ1eDZbYmezbyPVgiIDVrz+8Ou7w5F",
	"Lu9d2bI3QIdrbOvbiW3a+h57d+htklnkaJyUzLAgTGkXjvxJsczfn55jiQJrxTRtqNSFeEl+Y0o6fTEM",
	"ZQmiNU+7ggEul/ck0SkUdtKDbv0p9yychYufkA5Hi+9dXHy8oQMpA2C6h3xxtzqKW8/4zUjhoviMvbfK",
	"VSq6Z0UynHFiY8de1ry4+LikRdGr4RKHTyGTCTVIcLddBSdAFno9Uixp8jSXk6c5MX4n4ePaK3wTbyJ5",
	"BRFTa679jmOPVEjpeHhkW+NuOPUuxB/89zuhhld674scftYJ9JiorUkr0MlehrLJDjgZ4DshjoU4X7f/",
	"XXlTSrn03My7x7wDt/coFb5CTipaH7Ry51bmEUE87vZno07/No3KXcx+vKhCBAzQRhf0n76632t6fvT0",
	"CcLXfvIMjcvHtA9rKlZB5lerYiYOx5WdC2JhWw8QAykg7iEO79bRDPFeE/LWjkzLa7rR3lTaItb4cH5X",
	"sc5MwkwXp4aifTe9NyoHx9gHlvOaw1uhXS4YcHzcwDjyVisaKi3TwZw1fhWMFi6+m7aFHLvOL+/7ciXp",
	"aHRBz90207JrLcCBvTHYtnnlx/YrCkca3Wc7vH6WKPAZtnQLz3PeyUlm5yyF+/I47IVMDqcZ526i/9TS",
	"iFtE2Eb20L6n6rJzB1LdfScRExk6o3ZEjCj94A5Ppzlnwvv2dSsIpw6m/Z+YQgfmByoKWZE3jUAsePLT",
	"hzdP3fvpHsl8sQSLfA6SL/hVteXwVbXE22J2Sw71ntpl8ZneUysH76ndfaW7v6TmcWvsHTUfuI/uoxXX",
	"RiVMxI9fXWyKzXhX4DSfcV6LfRmN64acxs10N0EK5aiRd+dNqCfVuyLvJY50XmGlhlzbe1q7mqCtWNIN",
	"f2yr84oQxRhZ3LeGR3bHG3k2xUkkMAkUFUw86ando7CeC0fPf+OrV1hVuIzEhGUjCt3bwvYljwlf4aSU",
	"4IQE32bS7Th2fe56Z57FTsUuJOC0c4kP4fHZ/mM9UOkVa7rCA8D49my/TFO7lbWSV7xIvaFRyhXPNdoq",
	"9vVuvvN9b+ezqikNv+M43/u+6G5N35gcHIpnhoqCqoKw4utvvvnq23a5Xxi7Gm5SMhTFLcuZ46jheVfi",
	"C6vbgYn5ozxZySHLGvVKqVVrpA9eqDnUpm4jvfZzJgEg6fVGi/XBDIsNoRGqSyvgloa3P83tb2uq1y3r",
	"jOqLQ913Shy/6keoQY7L53msKSKK7F5BBD3yGGMcLZF8CbTRe8uM5zuzxO8jTjIsv+2WiAZKiy8+8Q/2",
	"ui6Zle1aHjikm1xtaiNP/dHgle/nPOPDJ0ni8dK7Dg2gnqi0kgjm8VthspW4QJVuobpDJOtgf85iuFJl",
	"DteKaQtROvJkrS4ufk4Lm5henpYu051u9zzbs96edncc921Uwq0vEYjHpeUtOPD4IA33/BaCm5cgjeVS",
	"GJqD3IgFrmcvnWlp5uopz9bG1PrF6en19fWJtzud5LI6XUGCRmZkk69P/UD4qlKc9uy6uEqElguXG8Nz",
	"TV6+fwsyEzclw6f12Q3YtwJmzb4+eYbZ8kzQms9ezJ6fPDv5CndsDUhwiiUlZi8+3c5np1dfn8ZBJavk",
	"I1mMqnyNioBrewKZ3wy1m7dFaPRGqpd+OOcgwGeCX3wcexDIkqz9+9eGqc3MV6mPDSat22pIHttzelGh",
	"1xisaBqFWdKKkdwLcZFPFp+xY1dMEI5iX8krHh6nUFapdbd2AmZouyfAbckqumIRvCfkR82iupDyEtIl",
	"UNz0wde+rGHoNAKYHSIFV4vyw4RW3DUn6kIsHBXeRr2CBCFwL4goyPKkU3PNGTXdIxWuQEW+IY0orXzh",
	"DfXgX9NhaVCOD2s35NTtgMtM8hGeevwE/CSZgzCzEO55Iq5yOehGcJm4mFSwBznVyeH4PBTbiD3s8/aB",
	"M2fSnpNQvqJni507D7l/v3j4LDD638cW7MJlM1qWqWVGXpn9Trh0z9p8ocdrp7jX2frYuMjx6d6ygfVC",
	"DU174JdsMwZMm0I6TllbI96mP4+B73ma9ze3L5NgKUIoUFwzBUOKHEzeGjDTW8mQL/uQh4JruiihWD+q",
	"wB1/+Sjyhfqpe5xAXNRjnPn3IwUmZvgZHtiAukhwhX397Jm/p51ZKxrt9BeNAlg74HiE5T4pEylB0Ven",
	"m0xHDYWF0TOB53qN91NVN2bce3tjMrgVhiP/qF08WE1XXLiYBzAWVfQSbEICk2dcyJGnTp99bK+aYC93",
	"l5PDmB1sNu39392An5NyVRfyJxB68BSFMGpV648zDZLF7Ofbnrxy+slHm/HidlR4eSflZVMHK1j8HsJA",
	"hsG27kS/2wB6TsowwbbmqR2Q2YpaES4HIGfxRhnVsL1u5F1p/4C0+p95Ez4Iw9iDTTwgW0iT4sEosQT6",
	"2EKJp/2nCnYhy75/ZIIu44cDttHnURs4jDYQlQ+wsyz5jcNO7zLPZa98lIBypr7WZhIKcL3BYHsLUGhE",
	"HZOfwtdPyYl9Jkg86QGyV1Lbxlfnm9ruQwkBpr/Y3fIY2LSuocDBfX5SsIlA7pDmK5IFC739pcKfwOpz",
	"xlf2pxJ/AnszWttSa9d8Nb54Dd0q/MeOt9MiHSVHC+ma2hcbV5QgfRZp8e6LvAb9lNQQqaKa4u3UFXdV",
	"vMemDw0OAgIWYO7DQG+2wOAb7Cu5P4jBpr+yaE34RI3hldU8HaOhgnx484o8f/78W/fiopU5EF3GFoxD",
	"Yu5lDFxgGAU14fMu7OfDm1cAwFkwYu7UauuhBow61MphxC9v4X9g49If0uryOdUkXLVTDpw0jcno0+JJ",
	"SFl/RF3iD2IwGL5mdv/qMyMPA/h7rjPhwdSfSNPdyXkStx/3n3RbTftQDm1M+6Maw4+K4p0UxQObUnr0",
	"tJv9tVvR8miD7WXaPaAdNprk9FOXy2y3x3br8ybtPW2TtC02JUX0ed1WSeJo/jwUze5JqY9nBn0g4+cU",
	"+p/6Ilk70gCx7XcghHdypT8PMRxvyMOYUj+zuewParuCYO6gBA4qY6DP30Xot8HpSQsqlsVq01ofxvX/",
	"YFx6vApNzYubXo0nLBI8kqzwkJJVKVeZf9NoXzHwnVy9punShb8HgQ1Z9QPdWaFMxlZdFVpOhfnhUFsU",
	"1KP6eLwc97it3oCjDP1kvkqLJym0iYec5Wku7ZodenY7+uhqac/KfoD5GsHN2Hz2237zHcSBc+CLKTCk",
	"3bi8bX5U88Ot4XnwAyn4MPzpJ48Y25V6V5die4iVbbi7HhPnzh/V+QdV57Wr2r4TFT5iJBNMeS9En8/+",
	"8uwve23N5Ntynadob29vt4tdESGduvfXtpoIUBbo1fO8XkvAs/glyElC85MdhbWjsHY4Ye0zROIcAwf+",
	"0wMHDnb9H/ZejPn1TpLq4OXho9DqXwZsb6OHNHLEt+0+Eckd42BcUG5Slj0GJR+Dko9Byceg5GNQ8iM7",
	"do7hw8fw4aMW8J8dPryL89ZXLeIirtkVs3z3fs8Yqj+wP3c+fNu6WnDBWjnar6BNzjbSHhQ0ih8v8g2h",
	"OLB32G1ZV6ZkOXK/+gdyQom1+cw/A0SVlZR3uW87q/EAQoG5aP641v5ea4M6sGAqIj5sG3FZ2H0uyw0x",
	"7sVaaoVBv5K5FZA3siHXQCwlv4T+8G4ixoJX+ApGNyceSug2o34e1z0LVYO3WZ8e3qJ9jHU/xro/cKw7",
	"PEqnTz/hM3aoum71B4V3k1N683f24zZdGdEAp0vnjcQAPa6FaOr8cHF33OudzBVRrMZ08nSI2DjaKI42",
	"iqON4mijONoojonTR8vH0fJxtHwcLR9Hy8fR8vFwlo/Paa34vRUePNpDvjx7yHz2zQFtApMhg/3Y284D",
	"BJ+stL89+pZYxagcvIaWMr6cd95u3x6C69SN3ety/I6II37Hfh803B3tvqxA1UfE6tayBW95qSuPYt1C",
	"6eyGVnXJoEY6pL65/qHEei6rCig//OJGjn5xFHT78+3/CwAA//+s8fVjygoBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
