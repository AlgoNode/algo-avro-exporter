// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
