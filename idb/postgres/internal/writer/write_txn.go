package writer

import (
	"context"
	"fmt"

	"github.com/algorand/go-algorand/data/bookkeeping"
	"github.com/algorand/go-algorand/data/transactions"
	"github.com/algorand/go-algorand/protocol"
	"github.com/jackc/pgx/v4"

	"github.com/algorand/indexer/idb"
	"github.com/algorand/indexer/idb/postgres/internal/encoding"
)

// Get the ID of the creatable referenced in the given transaction
// (0 if not an asset or app transaction).
// Note: ConsensusParams.MaxInnerTransactions could be overridden to force
//       generating ApplyData.{ApplicationID/ConfigAsset}. This function does
//       other things too, so it is not clear we should use it. The only
//       real benefit is that it would slightly simplify this function by
//       allowing us to leave out the intra / block parameters.
func transactionAssetID(stxnad *transactions.SignedTxnWithAD, intra uint, block *bookkeeping.Block) (uint64, error) {
	assetid := uint64(0)

	switch stxnad.Txn.Type {
	case protocol.ApplicationCallTx:
		assetid = uint64(stxnad.Txn.ApplicationID)
		if assetid == 0 {
			assetid = uint64(stxnad.ApplyData.ApplicationID)
		}
		if assetid == 0 {
			if block == nil {
				return 0, fmt.Errorf("transactionAssetID(): Missing ApplicationID for transaction: %s", stxnad.ID())
			}
			// pre v30 transactions do not have ApplyData.ConfigAsset or InnerTxns
			// so txn counter + payset pos calculation is OK
			assetid = block.TxnCounter - uint64(len(block.Payset)) + uint64(intra) + 1
		}
	case protocol.AssetConfigTx:
		assetid = uint64(stxnad.Txn.ConfigAsset)
		if assetid == 0 {
			assetid = uint64(stxnad.ApplyData.ConfigAsset)
		}
		if assetid == 0 {
			if block == nil {
				return 0, fmt.Errorf("transactionAssetID(): Missing ConfigAsset for transaction: %s", stxnad.ID())
			}
			// pre v30 transactions do not have ApplyData.ApplicationID or InnerTxns
			// so txn counter + payset pos calculation is OK
			assetid = block.TxnCounter - uint64(len(block.Payset)) + uint64(intra) + 1
		}
	case protocol.AssetTransferTx:
		assetid = uint64(stxnad.Txn.XferAsset)
	case protocol.AssetFreezeTx:
		assetid = uint64(stxnad.Txn.FreezeAsset)
	}

	return assetid, nil
}

type copyRow struct {
	value []interface{}
	err   error
}

type copyFromChannelStruct struct {
	ch   chan copyRow
	next copyRow
	err  error
}

func (c *copyFromChannelStruct) Next() bool {
	var ok bool
	c.next, ok = <-c.ch
	return ok
}

func (c *copyFromChannelStruct) Values() ([]interface{}, error) {
	if c.next.err != nil {
		c.err = c.next.err
		return nil, c.err
	}
	return c.next.value, c.next.err
}

func (c *copyFromChannelStruct) Err() error {
	return c.err
}

func copyFromChannel(ch chan copyRow) pgx.CopyFromSource {
	return &copyFromChannelStruct{ch: ch}
}

func yieldTransactions(block *bookkeeping.Block, modifiedTxns []transactions.SignedTxnInBlock, outch chan copyRow) {
	intra := uint(0)
	for idx, stib := range block.Payset {
		var stxnad transactions.SignedTxnWithAD
		// This function makes sure to set correct genesis information so we can get the
		// correct transaction hash.
		stxnad.SignedTxn, stxnad.ApplyData, _ = block.BlockHeader.DecodeSignedTxn(stib)

		txn := &stxnad.Txn
		typeenum, _ := idb.GetTypeEnum(txn.Type)
		assetid, _ := transactionAssetID(&stxnad, intra, block)
		id := txn.ID().String()

		extra := idb.TxnExtra{
			AssetCloseAmount: modifiedTxns[idx].ApplyData.AssetClosingAmount,
		}
		outch <- copyRow{
			value: []interface{}{
				uint64(block.Round()), intra, int(typeenum), assetid, id,
				encoding.EncodeSignedTxnWithAD(stxnad),
				encoding.EncodeTxnExtra(&extra)},
			err: nil,
		}

		intra++
	}

	close(outch)
}

// AddTransactions adds transactions from `block` to the database. `modifiedTxns`
// contains enhanced apply data generated by evaluator.
func AddTransactions(block *bookkeeping.Block, modifiedTxns []transactions.SignedTxnInBlock, tx pgx.Tx) error {
	ch := make(chan copyRow, 64)
	go yieldTransactions(block, modifiedTxns, ch)

	_, err := tx.CopyFrom(
		context.Background(),
		pgx.Identifier{"txn"},
		[]string{"round", "intra", "typeenum", "asset", "txid", "txn", "extra"},
		copyFromChannel(ch))
	if err != nil {
		return fmt.Errorf("addTransactions() copy from err: %w", err)
	}

	return nil
}
